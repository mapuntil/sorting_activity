<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sorting Discovery</title>

  <style>
    :root {
      --gap-lg: 16px;
      --gap-xl: 24px;
      --box-size: 48px;
    }

    body {
      font-family: Arial, sans-serif;
      line-height: 1.5;
      padding: 24px;
    }

    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--gap-lg);
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .counters {
      text-align: center;
      margin-top: 10px;
      margin-bottom: var(--gap-xl);
    }

    .counters span { margin: 0 20px; }

    .row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--gap-lg);
      margin-bottom: var(--gap-xl);
    }

    .letter-box {
      width: var(--box-size);
      height: var(--box-size);
      font-size: 24px;
      text-align: center;
    }

    #statusLabel {
      min-width: 140px;
      text-align: center;
      font-size: 22px;
      padding: 6px 10px;
      border-radius: 8px;
      background: #f4f4f4;
      transition: background 0.2s;
    }

    button {
      padding: 8px 14px;
      font-size: 14px;
      border-radius: 8px;
      cursor: pointer;
    }

    .reveal-btn {
      background: #007bff;
      color: white;
      border: 1px solid #007bff;
    }

    .reveal-btn:hover {
      background: #0069d9;
    }

    #tileArea {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 8px;
    }

    .tile {
      width: 48px;
      height: 48px;
      background: #e9eefc;
      border: 2px solid #9aa6d8;
      border-radius: 8px;
      line-height: 48px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      cursor: grab;
      user-select: none;
    }

    .tile.dragging { opacity: 0.6; border-style: dashed; }

    .chip {
      display: inline-block;
      padding: 6px 10px;
      margin: 4px;
      border: 1px solid #ccc;
      border-radius: 20px;
      font-weight: bold;
    }

    .divider {
      border: 0;
      border-top: 2px solid #ccc;
      margin: 30px 0;
    }
  </style>
</head>

<body>

  <h3>Setup</h3>
  <ul>
    <li>You are given a set of hidden numbers (represented by letters).</li>
    <li>You are <i>not allowed to look at the numbers</i>, but you are <i>allowed to compare any two of them</i> to see which one is larger.</li>
  </ul>

  <h3>Goal</h3>
  <ul>
    <li>Come up with an algorithm to sort these hidden numbers from <b>least to greatest</b> using <i>only</i> comparisons. Try to sort the numbers using as few comparisons as possible.</li>
  </ul>

  <h3>Hints</h3>
  <ul>
    <li>Start with a small quantity of numbers, i.e. four, and sort them, before increasing the quantity of numbers.</li>
    <li>Remember that your algorithm must be: <b>Specific</b>, and <b>Correct</b></li>
  </ul>

  <hr class="divider">

  <!-- Controls -->
  <div class="controls">
    <label for="letterCount">How many letters (from A…)?</label>
    <input type="number" id="letterCount" min="2" max="16" value="5">

    <button id="generateBtn">Generate</button>
    <button id="checkOrderBtn">Check Order</button>
    <button id="revealBtn" class="reveal-btn">Reveal Answer</button>
  </div>

  <div class="counters">
    <span>Unique comparisons: <span id="counter">0 / 45</span></span>
    <span>Total comparisons: <span id="totalCounter">0</span></span>
  </div>

  <div class="row">
    <input type="text" maxlength="1" class="letter-box" id="box1"
      ondrop="dropLetter(event, 'box1')" ondragover="event.preventDefault()">

    <label id="statusLabel">_</label>

    <input type="text" maxlength="1" class="letter-box" id="box2"
      ondrop="dropLetter(event, 'box2')" ondragover="event.preventDefault()">
  </div>

  <div id="tileArea"></div>

  <p style="text-align:center; color:#555; font-style:italic;">
    Drag and drop these tiles to arrange the letters, or drag them into the boxes above.
  </p>

  <div id="answerWrap" style="text-align:center;">
    <div id="answer" style="display:none;"></div>
  </div>

  <hr class="divider">

<script>
/* -----------------------------
   GLOBAL ELEMENTS
----------------------------- */
const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const box1 = document.getElementById("box1");
const box2 = document.getElementById("box2");
const label = document.getElementById("statusLabel");
const countInput = document.getElementById("letterCount");
const generateBtn = document.getElementById("generateBtn");
const revealBtn = document.getElementById("revealBtn");
const checkOrderBtn = document.getElementById("checkOrderBtn");
const answer = document.getElementById("answer");
const counterEl = document.getElementById("counter");
const totalEl = document.getElementById("totalCounter");
const tileArea = document.getElementById("tileArea");

/* -----------------------------
   STATE
----------------------------- */
let hiddenOrder = [];
let seenComparisons = new Set();
let uniqueCount = 0;
let totalCount = 0;
let maxComparisons = 0;

// NEW: track tile order so dragging into inputs doesn't change arrangement
let originalTileOrder = [];
let draggingIntoInput = false;

/* -----------------------------
   LABEL BUTTON
----------------------------- */
function showCompareButton() {
  label.textContent = "Compare";
  label.style.background = "#007bff";
  label.style.color = "white";
  label.style.cursor = "pointer";
  label.style.border = "1px solid #005ec2";
}

function showLabelResult(text) {
  label.textContent = text;
  label.style.background = "#f4f4f4";
  label.style.color = "black";
  label.style.cursor = "default";
  label.style.border = "none";
}

box1.addEventListener("input", showCompareButton);
box2.addEventListener("input", showCompareButton);

label.addEventListener("click", () => {
  if (label.textContent === "Compare") compareNow();
});

/* -----------------------------
   DRAG → DROP INTO INPUT ONLY
   (do NOT permanently reorder tiles)
----------------------------- */
function dropLetter(event, boxId) {
  event.preventDefault();
  const letter = event.dataTransfer.getData("text/plain");
  if (!letter) return;

  const box = document.getElementById(boxId);
  box.value = letter;
  showCompareButton();

  // mark that this drag was for input, not sorting
  draggingIntoInput = true;
  restoreTileOrder();
}

function restoreTileOrder() {
  if (!originalTileOrder.length) return;

  const currentTiles = Array.from(tileArea.children);
  const map = {};
  currentTiles.forEach(tile => {
    map[tile.textContent] = tile;
  });

  tileArea.innerHTML = "";
  originalTileOrder.forEach(letter => {
    if (map[letter]) tileArea.appendChild(map[letter]);
  });
}

/* -----------------------------
   FIXED SHUFFLE
----------------------------- */
function shuffleInPlace(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* -----------------------------
   HELPERS
----------------------------- */
function normalizeLetter(s) {
  if (!s) return "";
  return s.trim().toUpperCase();
}

function inDomain(ch) {
  return hiddenOrder.includes(ch);
}

/* -----------------------------
   BUILD NEW PUZZLE
----------------------------- */
function makeHiddenOrder(n) {
  const base = alphabet.slice(0, n);
  hiddenOrder = shuffleInPlace(base.slice());

  maxComparisons = n * (n - 1) / 2;
  uniqueCount = 0;
  totalCount = 0;
  seenComparisons.clear();
  updateCounter();

  renderAnswer();
  renderTiles(base);
  showLabelResult("_");
}

/* -----------------------------
   RENDER ANSWER + TILES
----------------------------- */
function renderAnswer() {
  answer.innerHTML = "";
  hiddenOrder.forEach(ch => {
    const span = document.createElement("span");
    span.className = "chip";
    span.textContent = ch;
    answer.appendChild(span);
  });
}

function renderTiles(baseLetters) {
  tileArea.innerHTML = "";
  let start = shuffleInPlace(baseLetters.slice());

  start.forEach(letter => {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.draggable = true;
    tile.textContent = letter;

    tile.addEventListener("dragstart", e => {
      tile.classList.add("dragging");
      e.dataTransfer.setData("text/plain", tile.textContent);

      // record order at start of drag
      originalTileOrder = Array.from(tileArea.children).map(t => t.textContent);
      draggingIntoInput = false;
    });

    tile.addEventListener("dragend", () => {
      tile.classList.remove("dragging");
      // if drag ended in an input, we already restored order
      // if it was a sort-drag inside tileArea, keep the new order
    });

    tileArea.appendChild(tile);
  });

  // initialize original order
  originalTileOrder = Array.from(tileArea.children).map(t => t.textContent);
  setupDragAndDrop();
}

/* -----------------------------
   COMPARISON
----------------------------- */
function compareNow() {
  const A = normalizeLetter(box1.value);
  const B = normalizeLetter(box2.value);
  const valid = ch => /^[A-Z]$/.test(ch);

  totalCount++;

  if (!valid(A) || !valid(B)) {
    showLabelResult("Type letters A–Z");
    updateCounter();
    return;
  }

  if (!inDomain(A) || !inDomain(B)) {
    showLabelResult("Out of range");
    updateCounter();
    return;
  }

  if (A === B) {
    showLabelResult(`${A} = ${B}`);
    updateCounter();
    return;
  }

  const idxA = hiddenOrder.indexOf(A);
  const idxB = hiddenOrder.indexOf(B);

  showLabelResult(idxA < idxB ? `${A} < ${B}` : `${A} > ${B}`);

  const key = [A, B].sort().join("|");
  if (!seenComparisons.has(key)) {
    seenComparisons.add(key);
    uniqueCount++;
  }

  updateCounter();
}

/* -----------------------------
   COUNTERS
----------------------------- */
function updateCounter() {
  counterEl.textContent = `${uniqueCount} / ${maxComparisons}`;
  totalEl.textContent = totalCount;
}

/* -----------------------------
   CHECK ORDER
----------------------------- */
checkOrderBtn.addEventListener("click", () => {
  const curr = Array.from(tileArea.children).map(t => t.textContent).join("");
  const correct = hiddenOrder.join("");
  alert(curr === correct ? "✅ Correct!" : "❌ Not quite.");
});

/* -----------------------------
   DRAG SORTING
----------------------------- */
function setupDragAndDrop() {
  const tiles = tileArea.querySelectorAll(".tile");

  tiles.forEach(tile => {
    tile.addEventListener("dragstart", () => tile.classList.add("dragging"));
    tile.addEventListener("dragend", () => tile.classList.remove("dragging"));
  });

  tileArea.addEventListener("dragover", e => {
    e.preventDefault();

    // if this drag was used to drop into an input, don't sort
    if (draggingIntoInput) return;

    const dragging = document.querySelector(".dragging");
    if (!dragging) return;

    const after = getAfter(tileArea, e.clientX);
    if (!after) tileArea.appendChild(dragging);
    else tileArea.insertBefore(dragging, after);
  });
}

function getAfter(container, x) {
  const els = [...container.querySelectorAll(".tile:not(.dragging)")];
  return els.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = x - box.left - box.width / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset, element: child };
    }
    return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

/* -----------------------------
   BUTTONS
----------------------------- */
generateBtn.addEventListener("click", () => {
  const n = Math.max(2, Math.min(16, parseInt(countInput.value)));
  makeHiddenOrder(n);
});

revealBtn.addEventListener("click", () => {
  if (answer.style.display === "none") {
    answer.style.display = "block";
    revealBtn.textContent = "Hide Answer";
  } else {
    answer.style.display = "none";
    revealBtn.textContent = "Reveal Answer";
  }
});

/* -----------------------------
   INIT
----------------------------- */
makeHiddenOrder(parseInt(countInput.value, 10));

</script>

</body>
</html>
